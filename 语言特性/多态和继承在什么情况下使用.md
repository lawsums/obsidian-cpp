
**多态 (Polymorphism)** 和 **继承 (Inheritance)** 是面向对象编程（OOP）的两大核心支柱，它们通常结合使用来构建灵活、可扩展的软件系统。以下是它们的主要使用场景：

#### **继承的使用场景：**

1. **代码复用 (Code Reuse)**：
    
    - 当多个类具有共同的属性和行为时，可以将这些共性提取到一个基类中。
    - 派生类通过继承自动获得基类的成员，避免了重复编写相同的代码。
    - **例子**：`Vehicle` 基类包含 `speed`, `color` 等属性和 `start()`, `stop()` 方法。`Car`, `Truck`, `Motorcycle` 类继承 `Vehicle`，复用这些通用功能。
2. **建立“是一个”(is-a) 关系**：
    
    - 继承用于表示类型之间的层次关系，即派生类是基类的一种特殊形式。
    - **例子**：`Dog` 是一种 `Animal`，`Rectangle` 是一种 `Shape`，`Manager` 是一种 `Employee`。
3. **分层设计与模块化**：
    
    - 将复杂的系统分解为具有层次结构的类，使设计更清晰、易于理解和维护。

#### **多态的使用场景：**

1. **统一接口处理不同类型对象**：
    
    - 这是多态最核心的应用。通过基类指针或引用，可以调用不同派生类对象的同名函数，程序会根据实际对象类型自动执行正确的版本。
    - **例子**：有一个 `std::vector<Shape*> shapes;` 存储各种形状（`Circle`, `Rectangle`）。遍历该容器并调用 `shape->draw()` 或 `shape->area()`，无需关心具体类型，系统会自动调用对应类的实现。
2. **提高代码的可扩展性**：
    
    - 当需要添加新类型时（如新增 `Triangle` 类），只要它继承自 `Shape` 并实现 `area()`，现有调用 `area()` 的代码完全不需要修改。这符合“开闭原则”（对扩展开放，对修改关闭）。
3. **解耦与依赖倒置**：
    
    - 高层模块（如主程序逻辑）依赖于抽象基类，而不是具体的派生类。这降低了模块间的耦合度，使系统更灵活，易于测试和维护。
4. **实现回调、事件处理、插件架构等**：
    
    - 许多设计模式（如策略模式、观察者模式）都依赖多态来实现运行时的行为切换。

**总结**：当你有一组相关的类共享公共特性（用**继承**），并且希望以统一的方式处理它们，让程序能根据对象的实际类型表现出不同的行为（用**多态**）时，就应该使用继承和多态。