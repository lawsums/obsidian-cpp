出了问题直接返回，那么后续语句就不会执行
但是对于局部对象的析构函数依旧会执行，因为脱离了它的生命周期，此时需要回收资源，所以我们利用智能指针，将 new 的对象绑定为它的资源就可以了，退出函数得时候会自动析构释放资源

## 详细说明
### 1. 先理解“出问题直接返回，后续语句不执行”的痛点
当函数中用`new`手动分配内存（如`int* p = new int;`），若后续因错误（如`if (err) return;`）或异常提前退出，**后续用于释放内存的`delete p;`会被跳过**——此时`new`的内存无法回收，导致“内存泄漏”。
示例（有风险的代码）：
```cpp
void func() {
    int* p = new int; // 手动分配内存
    if (some_error) {
        return; // 提前返回，下面的delete被跳过
    }
    // 业务逻辑...
    delete p; // 正常流程才会执行，异常/提前返回时不执行
}
```


### 2. “局部对象析构函数依旧执行”的关键特性
C++有个核心规则：**局部对象（在栈上创建的对象，如`MyClass obj;`）离开作用域（如函数返回、代码块结束）时，会自动调用其析构函数**——无论退出方式是“正常执行完”还是“提前返回/抛异常”，这个过程都不会跳过。  
这是“资源自动回收”的基础：只要把“需要释放的资源（如`new`的内存）”交给局部对象管理，让对象的析构函数负责释放资源，就能确保资源不泄漏。


### 3. 智能指针的作用：绑定`new`资源到局部对象
智能指针（如`std::unique_ptr`、`std::shared_ptr`）本质是**封装了原始指针的“局部类对象”**，其核心设计就是：  
- 构造时：接收`new`返回的原始指针，将内存资源“绑定”到自身；  
- 析构时：自动调用`delete`释放绑定的内存（或计数减1，计数为0时释放）。  

示例（安全的代码）：
```cpp
#include <memory> // 智能指针头文件
void func() {
    // 用智能指针管理new的内存，ptr是局部对象
    std::unique_ptr<int> p(new int); 
    if (some_error) {
        return; // 提前返回：ptr离开作用域，自动调用析构→释放内存
    }
    // 业务逻辑...
    // 无需手动delete：函数结束时ptr析构，自动释放
}
```


### 总结核心逻辑
手动`new`的风险 → 局部对象析构必执行的特性 → 智能指针用“局部对象+析构释放”绑定`new`资源 → 无论正常/提前退出，资源都能自动回收，避免泄漏。  
这也是C++中“RAII（资源获取即初始化）”设计思想的典型应用——将资源管理与对象生命周期绑定。