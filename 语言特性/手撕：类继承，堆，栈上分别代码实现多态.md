

要理解**类继承中的多态**，核心是借助 **虚函数（`virtual`）** 实现“基类指针/引用调用子类重写方法”的能力。而“堆/栈上实现”的本质，是**子类对象的创建位置不同**（栈上为自动变量，堆上为动态分配变量），但多态的核心逻辑（虚函数表机制）完全一致。


### 一、基础概念铺垫
1. **多态的前提**：
   - 存在类继承关系（基类 + 子类）。
   - 基类中定义**虚函数**（用 `virtual` 修饰），子类**重写**（override）该虚函数（函数签名、返回值完全一致）。
   - 通过**基类指针或基类引用**指向子类对象，触发多态调用。

2. **堆 vs 栈的区别**：
   - **栈上对象**：自动分配内存，生命周期随作用域结束而自动销毁（无需手动释放）。
   - **堆上对象**：需用 `new` 动态分配，生命周期由程序员控制，必须用 `delete` 手动释放（否则内存泄漏）。


### 二、完整代码实现（堆 + 栈）
下面通过“动物（基类）→ 猫/狗（子类）”的经典案例，分别实现栈上和堆上的多态调用。

```cpp
#include <iostream>
#include <string>
using namespace std;

// 1. 基类：动物（Animal）
class Animal {
public:
    // 虚函数：动物叫（子类需重写）
    virtual void makeSound() const { 
        cout << "动物发出声音" << endl; 
    }

    // 虚析构函数：确保子类对象销毁时，先调用子类析构，再调用基类析构
    virtual ~Animal() { 
        cout << "Animal 析构函数" << endl; 
    }

private:
    string name; // 基类成员（可选）
};

// 2. 子类1：猫（Cat）- 继承自Animal
class Cat : public Animal {
public:
    // 重写基类的虚函数（多态核心）
    void makeSound() const override { 
        cout << "小猫喵喵叫~" << endl; 
    }

    // 子类析构函数（自动调用，无需手动加virtual，但加了也没问题）
    ~Cat() { 
        cout << "Cat 析构函数" << endl; 
    }
};

// 3. 子类2：狗（Dog）- 继承自Animal
class Dog : public Animal {
public:
    // 重写基类的虚函数
    void makeSound() const override { 
        cout << "小狗汪汪叫！" << endl; 
    }

    ~Dog() { 
        cout << "Dog 析构函数" << endl; 
    }
};

// 4. 通用函数：接收基类引用，触发多态调用（也可改为基类指针）
void animalCry(const Animal& animal) { 
    animal.makeSound(); // 多态调用：具体调用哪个子类的方法，取决于传入的对象
}

// 5. 主函数：分别测试栈上、堆上的多态
int main() {
    cout << "------------------- 栈上对象的多态 -------------------" << endl;
    // 栈上创建子类对象（自动分配内存）
    Cat stackCat;   // 猫对象在栈上
    Dog stackDog;   // 狗对象在栈上

    // 通过基类引用调用：触发多态
    animalCry(stackCat); // 输出“小猫喵喵叫~”
    animalCry(stackDog); // 输出“小狗汪汪叫！”

    // 栈上对象：main函数结束后自动销毁（先析构子类，再析构基类）
    cout << endl;


    cout << "------------------- 堆上对象的多态 -------------------" << endl;
    // 堆上创建子类对象（动态分配内存，返回基类指针）
    Animal* heapCat = new Cat();  // 猫对象在堆上，基类指针指向它
    Animal* heapDog = new Dog();  // 狗对象在堆上，基类指针指向它

    // 通过基类指针调用：触发多态
    heapCat->makeSound();  // 输出“小猫喵喵叫~”
    heapDog->makeSound();  // 输出“小狗汪汪叫！”

    // 堆上对象：必须手动delete释放（虚析构保证析构顺序正确）
    delete heapCat;  // 先析构Cat，再析构Animal
    delete heapDog;  // 先析构Dog，再析构Animal

    return 0;
}
```


### 三、关键细节解析
#### 1. 虚函数与多态的核心逻辑
- 基类 `Animal` 中的 `makeSound()` 用 `virtual` 修饰后，编译器会为 `Animal` 及其子类生成**虚函数表（vtable）**，存储虚函数的地址。
- 每个对象会隐含一个**虚表指针（vptr）**，指向所属类的虚函数表。
- 当通过“基类指针/引用”调用虚函数时，编译器会通过 `vptr` 找到子类的虚函数表，进而调用子类重写的方法（而非基类的方法）——这就是多态的底层原理。


#### 2. 虚析构函数的必要性
- 如果基类析构函数不是 `virtual`，当用“基类指针”删除“子类对象”时，只会调用**基类析构函数**，子类的资源（如子类特有的成员变量）无法释放，导致内存泄漏。
- 上述代码中，`Animal` 的析构函数加了 `virtual`，因此 `delete heapCat` 时会先调用 `Cat` 的析构函数，再调用 `Animal` 的析构函数，确保资源完全释放。


#### 3. 栈上多态的特点
- 栈上对象的创建无需 `new`，直接定义变量即可（如 `Cat stackCat`）。
- 调用多态时，可直接将栈上的子类对象传给“基类引用参数”（如 `animalCry(stackCat)`），无需手动管理生命周期。


#### 4. 堆上多态的特点
- 堆上对象需用 `new` 创建，且返回的指针必须是**基类指针**（如 `Animal* heapCat = new Cat()`），才能触发多态。
- 堆上对象必须用 `delete` 手动释放，且释放时必须通过“基类指针”（不能用子类指针，否则失去多态意义）。


### 四、输出结果与分析
运行上述代码，输出如下（重点关注析构顺序）：
```
------------------- 栈上对象的多态 -------------------
小猫喵喵叫~
小狗汪汪叫！

------------------- 堆上对象的多态 -------------------
小猫喵喵叫~
小狗汪汪叫！
Cat 析构函数
Animal 析构函数
Dog 析构函数
Animal 析构函数
```
- **栈上对象**：`main` 函数结束后才会销毁，因此栈上对象的析构输出在程序末尾（上述输出中未显示，因为栈上对象的析构在 `return 0` 后执行）。
- **堆上对象**：`delete` 时立即销毁，且先析构子类，再析构基类，符合“子类资源优先释放”的逻辑。


### 五、常见误区
1. **直接用子类指针调用方法，不算多态**：  
   若写成 `Cat* catPtr = new Cat(); catPtr->makeSound();`，虽然也会调用 `Cat` 的方法，但这是“静态绑定”（编译时确定调用哪个方法），不是多态（多态是“动态绑定”，运行时确定调用哪个方法）。

2. **基类函数未加 `virtual`，子类重写也无效**：  
   若 `Animal` 的 `makeSound()` 没有 `virtual`，即使子类重写了该函数，通过基类指针调用时仍会调用基类的方法，无法触发多态。


通过以上实现和解析，可以清晰理解：**多态的核心是虚函数和动态绑定，而堆/栈只是对象的存储位置，不影响多态的本质逻辑**。实际开发中，堆上多态更适合对象生命周期较长、需要动态管理的场景，栈上多态则适合轻量级、短期使用的场景。