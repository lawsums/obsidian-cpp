什么情况下会产生循环引用
两个对象的资源中互相含有对方的智能指针 shared_ptr以至于无法释放资源

## 详细说明

当两个或多个对象通过 **shared_ptr（共享智能指针）** 互相持有对方的引用，且没有外部其他有效 shared_ptr 指向这个对象集合时，就会产生循环引用，导致资源无法释放。其核心原因是 shared_ptr 的“引用计数”机制被循环依赖卡住，无法降为 0 触发析构。

### 关键逻辑拆解
shared_ptr 的核心原理是 **引用计数**：
1. 每创建一个指向对象 A 的 shared_ptr，A 的引用计数 +1；
2. 每销毁一个指向 A 的 shared_ptr（如超出作用域、被重置），A 的引用计数 -1；
3. 当 A 的引用计数 **降为 0** 时，shared_ptr 才会自动调用 A 的析构函数，释放内存。

而循环引用会打破这个逻辑：
- 假设存在对象 A 和 B，A 内部用 shared_ptr\<B\> 持有 B，B 内部也用 shared_ptr\<A\> 持有 A；
- 此时 A 的引用计数至少为 1（来自 B 的持有），B 的引用计数也至少为 1（来自 A 的持有）；
- 即使外部所有指向 A、B 的 shared_ptr 都已销毁（如外部指针被重置），A 和 B 仍会互相“续命”，引用计数永远无法降到 0，最终导致 A、B 的内存永远无法释放，形成内存泄漏。


### 简单示例（C++）
```cpp
#include <memory>
Class B; // 前向声明
Class A {
Public:
    std::shared_ptr<B> b_ptr; // A 用 shared_ptr 持有 B
    ~A () { /* 析构时本应释放资源，但循环引用会导致此函数不被调用 */ }
};
Class B {
Public:
    std::shared_ptr<A> a_ptr; // B 用 shared_ptr 持有 A
    ~B () { /* 同理，析构函数无法执行 */ }
};

Void test () {
    // 外部创建 A 和 B 的 shared_ptr
    std::shared_ptr<A> a = std::make_shared<A>();
    std::shared_ptr<B> b = std::make_shared<B>();
    
    // 互相持有，形成循环引用
    A->b_ptr = b; 
    B->a_ptr = a;
    
    // 此时，a 和 b 超出作用域，外部引用计数清零
    // 但 A 的引用计数仍为 1（来自 B::a_ptr），B 的引用计数仍为 1（来自 A::b_ptr）
    // A 和 B 的析构函数不会执行，内存泄漏
}
```


### 解决方案核心
要避免这种情况，需将循环依赖中的 **至少一方** 改为 **weak_ptr（弱智能指针）**。Weak_ptr 不参与 shared_ptr 的引用计数计算，仅作为“观察者”持有对象引用，不会阻止对象的析构，从而打破循环。