
DECK: 面试题

## C++的锁你知道几种？


## 标准答案

锁包括
1. 互斥锁
2. 条件变量
3. 自旋锁
4. 读写锁

在并发编程中，“锁”是解决多线程/进程资源竞争、保证数据一致性的核心同步机制，以下是对 4 类常见锁的简要解析：


### 1. 互斥锁（Mutex）
- **核心逻辑**：“排他性占用”——同一时间仅允许一个线程/进程获取锁并访问资源，其他竞争线程/进程会被**阻塞挂起**（释放 CPU 资源，进入等待队列），直到锁被释放后重新竞争。
- **适用场景**：资源访问时间较长（如 IO 操作、复杂计算），阻塞的“上下文切换”开销远小于自旋等待的开销。
- **典型特点**：保证“互斥性”，但不保证“公平性”（默认通常是抢占式，先等的线程未必先拿到锁）。


### 2. 条件变量（Condition Variable）
- **核心逻辑**：并非独立“锁”，而是配合互斥锁使用的“等待-通知机制”——线程获取互斥锁后，若发现“目标条件未满足”（如队列空、数据未就绪），会释放互斥锁并**阻塞等待**；当其他线程满足条件后，通过“通知”唤醒等待线程，让其重新获取锁并执行。
- **适用场景**：需要线程间“基于条件协作”的场景（如生产者-消费者模型：消费者等队列非空，生产者填数据后通知消费者）。
- **典型特点**：解决“互斥锁无法判断条件”的问题，避免线程“拿着锁空等”导致的资源浪费。


### 3. 自旋锁（Spinlock）
- **核心逻辑**：“忙等”——线程竞争锁时，若锁已被占用，不会阻塞挂起，而是**循环检测锁的状态**（持续占用 CPU），直到锁被释放后立即获取。
- **适用场景**：资源访问时间极短（如仅修改一个全局变量），“自旋等待”的 CPU 开销远小于阻塞的“上下文切换”开销（避免切换线程的内核态/用户态开销）。
- **典型特点**：效率高但耗 CPU，不适合单核环境（单核下自旋会占满 CPU，导致持有锁的线程无法执行），且易引发“优先级反转”（低优先级线程自旋占 CPU，高优先级线程无法获取锁）。


### 4. 读写锁（Read-Write Lock）
- **核心逻辑**：“区分读写操作的锁”，遵循“读共享、写排他”规则：
  - 读操作：多个线程可同时获取“读锁”，并发读资源（无竞争）；
  - 写操作：仅允许一个线程获取“写锁”，且写锁与读锁、其他写锁完全互斥（写时禁止任何读/写）。
- **适用场景**：“读多写少”的场景（如缓存查询、配置读取），避免读操作因互斥锁而串行化，提升并发效率。
- **典型特点**：兼顾“读并发”和“写互斥”，但实现比互斥锁复杂，若写操作频繁，反而可能因“写锁竞争”导致效率下降。

## 我的答案

1. 递归锁 
2. 自旋锁
3. 普通锁


END
<!--ID: 1765808121798-->
