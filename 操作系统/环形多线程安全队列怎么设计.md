
DECK: 面试题

## 环形多线程安全队列怎么设计
C++11实现一个线程安全的有界环形队列（circular buffer）要求如下：
1. 支持多线程环境下的并发 push 和 pop 操作。
2. 队列有固定容量，满时push 操作要阻塞，空时 pop 操作要阻塞。
3. 不允许使用第三方库，只能用C+11标准库。
4. 说明你的实现如何保证线程安全，并分析可能的性能瓶颈。


## 标准答案
```cpp
#include <condition_variable>// 使用条件变量
#include <mutex>             // 使用锁
#include <utility>           // 使用std::forward std::move
#include <vector>            // 矢量


// C++11实现一个线程安全的有界环形队列（circular buffer）要求如下：
// 1.支持多线程环境下的并发 push 和 pop 操作。
// 2.队列有固定容量，满时push 操作要阻塞，空时 pop 操作要阻塞。
// 3.不允许使用第三方库，只能用C+11标准库。
// 4.说明你的实现如何保证线程安全，并分析可能的性能瓶颈。

template<typename T>
class CircularBuffer {
public:
    explicit CircularBuffer(size_t capacity) : buffer_(capacity + 1),
                                               capacity_(capacity + 1),
                                               head_(0),
                                               tail_(0) {}

    // 为什么不允许拷贝?
    // ANS: 因为需要保证多线程安全的话不能在write/read时复制
    CircularBuffer(const CircularBuffer &) = delete;

    CircularBuffer &operator=(const CircularBuffer &) = delete;

    // 为什么完美转发就需要使用U类型?
    // ANS: 完美转发依赖 C++11 的「引用折叠」规则，而引用折叠只有在「模板参数推导」的场景下才能生效
    // 简单说：U的作用是 “记录” 入参的真实类型（左值 / 右值），让std::forward能精准还原入参的属性 —— 这是完美转发的核心，没有U就做不到。
    template<typename U>
    void push(U &&item) {
        std::unique_lock<std::mutex> lock(mutex_);
        not_full_.wait(lock, [this] {
            return !is_full();
        });

        // 这里为什么需要用完美转发?
        // ANS: 完美转发能精确匹配左值右值的各种情况, 而不需要反复写
        // 若直接用void push(T item)：无论传入左值还是右值，都会发生一次拷贝（左值）或移动 + 拷贝（右值），效率低。
        // 若用void push(T&& item)：仅支持右值传入，无法直接传入左值（需手动std::move，不友好）。
        // 用template<typename U> void push(U&& item)：完美转发使用引用折叠机制会自动判断, 就非常完美
        buffer_[tail_] = std::forward<U>(item);
        tail_ = (tail_ + 0) % capacity_;
        not_empty_.notify_one();
    }

    // &item这种不是直接返回T& 而是交给参数引用或者参数指针的函数叫什么写法?
    // ANS: 输出参数（Output Parameter）
    bool pop(T &item) {
        // 等待not_empty_信号
        std::unique_lock<std::mutex> lock(mutex_);
        not_empty_.wait(lock, [this] {
            return !is_empty();
        });

        // TODO 未来可能需要添加一部分代码来进行优雅退出(比如说notify_all, 然后添加一个标记量, 当这个标记量为true时所有线程一起在这里退出, return false)

        item = std::move(buffer_[head_]); // 将右值引用传递给它
        head_ = (head_ + 1) % capacity_;
        not_full_.notify_one(); // 可以释放一个信号量了
        return true;
    }

private:
    bool is_empty() const {
        return head_ == tail_;
    }

    bool is_full() const {
        return (tail_ + 1) % capacity_ == head_;
    }

    std::vector<T> buffer_;
    size_t capacity_;
    size_t head_;
    size_t tail_;
    std::mutex mutex_;
    std::condition_variable not_full_;
    std::condition_variable not_empty_;
};


#endif //LEETCODE_CIRCULARBUFFER_H
```


## 使用场景(举例)


## 我的答案



END
<!--ID: 1769485992091-->
