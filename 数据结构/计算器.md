

DECK: 面试题-hot100

## 计算器

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

**示例 1：**

**输入：** s = "1 + 1"
**输出：** 2

**示例 2：**

**输入：** s = " 2-1 + 2 "
**输出：** 3

**示例 3：**

**输入：** s = "(1+(4+5+2)-3)+(6+8)"
**输出：** 23

**提示：**

- `1 <= s.length <= 3 * 105`
- `s` 由数字、`'+'`、`'-'`、`'('`、`')'`、和 `' '` 组成
- `s` 表示一个有效的表达式
- `'+'` 不能用作一元运算(例如， `"+1"` 和 `"+(2 + 3)"` 无效)
- `'-'` 可以用作一元运算(即 `"-1"` 和 `"-(2 + 3)"` 是有效的)
- 输入中不存在两个连续的操作符
- 每个数字和运行的计算将适合于一个有符号的 32位 整数

---

相关标签
#栈
#递归
#数学
#字符串

---

相似题目

 [逆波兰表达式求值](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

中等

 [基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)

中等

 [为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)

中等

 [给表达式添加运算符](https://leetcode.cn/problems/expression-add-operators/)

困难

 [基本计算器 III](https://leetcode.cn/problems/basic-calculator-iii/)

困难

 [解出数学表达式的学生分数](https://leetcode.cn/problems/the-score-of-students-solving-math-expression/)

困难

 [向表达式添加括号后的最小结果](https://leetcode.cn/problems/minimize-result-by-adding-parentheses-to-expression/)
 
## 思路

计算器这道题需要好好讲一下

首先计算器类题目分两类，这一道题最加**全面和经典**

第一类是普通计算类
第二类是**嵌套**计算类

普通计算类中只需要设计**运算符的运算规则**和**优先级**
嵌套计算类中需要考虑**多层括号**

这道题需要设计几个函数
1. F
2. Push
3. Compute

F 函数是这道题的主要函数，`long long f(int i)` 用于**从 i 开始计算这个嵌套括号内的运算结果然后返回给上一级**

Push 函数 `void push(vector<long long>& nums, vector<char>& ops, long long cur_num, char cur_op)` 用来**加入符号，然后提前运算乘除操作以及结算tmp数字**

Compute 用来**将最后的符号栈和数字栈结算**

## 标准解法

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <cctype>
using namespace std;

class Solution {
private:
    string s;          // 存储输入字符串
    int where;         // 记录递归处理时的当前位置
    const int MAX_DEPTH = 10000; // 递归深度限制，防止栈溢出
    int cur_depth;     // 当前递归深度

    // 处理数字和运算符入栈，考虑运算符优先级
    void push(vector<long long>& nums, vector<char>& ops, long long cur_num, char cur_op) {
        if (ops.empty() || ops.back() == '+' || ops.back() == '-') {
            nums.push_back(cur_num);
            ops.push_back(cur_op);
        } else {
            // 处理乘除法的优先级
            if (ops.back() == '*') {
                nums.back() *= cur_num;
            } else { // 除法，向零取整（C++整数除法默认向零取整）
                nums.back() = static_cast<long long>(nums.back() / cur_num);
            }
            ops.back() = cur_op; // 更新运算符
        }
    }

    // 递归处理表达式，i是当前处理位置
    long long f(int i) {
        // 递归深度超限保护，避免栈溢出
        if (++cur_depth > MAX_DEPTH) {
            cur_depth--;
            return 0;
        }

        vector<long long> nums;  // 存储数字，预分配容量减少扩容
        vector<char> ops;
        nums.reserve(100);       // 预设容量，降低内存碎片
        ops.reserve(100);
        long long tmp = 0;       // 临时存储当前数字
        
        while (i < s.size() && s[i] != ')') {
            if (isdigit(s[i])) { // 解析数字
                tmp = tmp * 10 + (s[i] - '0');
                i++;
            } else if (s[i] == '+' || s[i] == '-' || s[i] == '*' || s[i] == '/') { // 遇到运算符
                push(nums, ops, tmp, s[i]);
                i++;
                tmp = 0;
            } else if (s[i] == '(') { // 遇到左括号，递归处理
                tmp = f(i + 1);
                // 边界检查：防止where越界导致无限循环
                if (where >= s.size()) {
                    break;
                }
                i = where + 1; // 跳转到括号后的位置
            } else { // 跳过空格
                i++;
            }
        }
        
        // 处理最后一个数字
        push(nums, ops, tmp, '+');
        where = i; // 更新位置信息
        cur_depth--; // 递归深度回退
        return compute(nums, ops);
    }

    // 计算加减法表达式
    long long compute(vector<long long>& nums, vector<char>& ops) {
        // 边界保护：空容器直接返回0
        if (nums.empty()) return 0;
        
        long long res = nums[0];
        for (int i = 1; i < nums.size(); i++) {
            // 防越界：运算符数量应比数字少1
            if (i-1 >= ops.size()) break;
            if (ops[i-1] == '+') {
                res += nums[i];
            } else {
                res -= nums[i];
            }
        }
        return res;
    }

public:
    int calculate(string s) {
        this->s = s;
        where = 0;          // 重置位置
        cur_depth = 0;      // 重置递归深度
        return static_cast<int>(f(0));
    }
};

```

#### Python 做法
``` python
class Solution:
    def __init__(self):
        self.s = ""      # 存储输入字符串
        self.where = 0    # 记录递归处理时的当前位置

    def push(self, nums, ops, cur_num, cur_op):
        """处理数字和运算符入栈，考虑运算符优先级"""
        if not ops or ops[-1] == "+" or ops[-1] == '-':
            nums.append(cur_num)
            ops.append(cur_op)
        else:
            # 处理乘除法的优先级
            if ops[-1] == "*":
                nums[-1] *= cur_num
            else:
                # 题目要求除法向零取整
                nums[-1] = int(nums[-1] / cur_num)
            ops[-1] = cur_op  # 更新运算符

    def f(self, i: int):
        """递归处理表达式，i是当前处理位置"""
        nums = []   # 存储数字
        ops = []    # 存储运算符
        tmp = 0     # 临时存储当前数字
        
        while i < len(self.s) and self.s[i] != ')':
            if self.s[i].isdigit():
                tmp = tmp * 10 + int(self.s[i])
                i += 1
            elif self.s[i] in '+-*/':  # 遇到运算符
                self.push(nums, ops, tmp, self.s[i])
                i += 1
                tmp = 0
            elif self.s[i] == '(':     # 遇到左括号，递归处理
                tmp = self.f(i + 1)
                i = self.where + 1    # 跳转到括号后的位置
            else:                      # 跳过空格
                i += 1
        
        # 处理最后一个数字
        self.push(nums, ops, tmp, '+')
        self.where = i  # 更新位置信息
        return self.compute(nums, ops)

    def compute(self, nums, ops):
        """计算加减法表达式"""
        res = nums[0]
        for i in range(1, len(nums)):
            if ops[i-1] == '+':
                res += nums[i]
            else:
                res -= nums[i]
        return res

    def calculate(self, s: str) -> int:
        """主方法"""
        self.s = s
        return self.f(0)
```

## 我的解法


END
<!--ID: 1764899441078-->

