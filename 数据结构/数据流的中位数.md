DECK: 面试题-hot100

## 数据流的中位数

## 标准解法

cpp默认priority_queue是最大堆

分类讨论：

1. 如果当前 left 的大小和 right 的大小相等：
	- 如果添加的数字 num 比较大，比如添加 7，那么把 7 加到 right 中。现在 left 比 right 少 1 个数，不符合前文的规定，所以必须把 right 的最小值从 right 中去掉，添加到 left 中。如此操作后，可以保证 left 的所有元素都小于等于 right 的所有元素。
	- 如果添加的数字 num 比较小，比如添加 0，那么把 0 加到 left 中。
	- 这两种情况可以合并：无论 num 是大是小，都可以先把 num 加到 right 中，然后把 right 的最小值从 right 中去掉，并添加到 left 中。
2. 如果当前 left 比 right 多 1 个数：
	- 如果添加的数字 num 比较大，比如添加 7，那么把 7 加到 right 中。
	- 如果添加的数字 num 比较小，比如添加 0，那么把 0 加到 left 中。现在 left 比 right 多 2 个数，不符合前文的规定，所以必须把 left 的最大值从 left 中去掉，添加到 right 中。如此操作后，可以保证 left 的所有元素都小于等于 right 的所有元素。
	- 这两种情况可以合并：无论 num 是大是小，都可以先把 num 加到 left 中，然后把 left 的最大值从 left 中去掉，并添加到 right 中。


``` cpp
class MedianFinder {
    priority_queue<int> left; // 最大堆
    priority_queue<int, vector<int>, greater<>> right; // 最小堆

public:
    void addNum(int num) {
        // 只有两个情况：
        
        // 1. len(right) == len(left)
        if (left.size() == right.size()) {
            right.push(num);
            left.push(right.top());
            right.pop();
        } 
        // 2. len(right) + 1 == len(left)
        else { 
            left.push(num);
            right.push(left.top());
            left.pop();
        }
    }

    double findMedian() {
        if (left.size() > right.size()) {
            return left.top();
        }
        return (left.top() + right.top()) / 2.0;
    }
};
```

## 我的解法

``` cpp
#include <bits/stdc++.h>
#include <functional>
#include <queue>
using namespace std;

class MedianFinder {
private:
    priority_queue<int, vector<int>, greater<>> minH;
    priority_queue<int, vector<int>, less<>> maxH;

public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (minH.empty()) { // 如果最小堆没有元素
            minH.push(num);
            return;
        }
        
        // 假设minH.size() == maxH.size() or minH.size() == maxH.size() + 1
        // 不能直接都给最小堆
        // 需要和最大堆堆顶对比一下
        // 如果大于等于最大堆堆顶，直接给最小堆，否则给最大堆
        if (!maxH.empty() && num < maxH.top()) {
            maxH.push(num);
        } else {
            minH.push(num);
        }

        if (minH.size() > maxH.size() + 1) {
            maxH.push(minH.top()); 
            minH.pop();
        }
        if (minH.size() < maxH.size()) {
            minH.push(maxH.top()); 
            maxH.pop();
        }
    }
    
    double findMedian() {
        if (minH.size() == maxH.size()) {
            return (minH.top() + maxH.top()) / 2.0;
        }
        return minH.top();
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```

END
<!--ID: 1763361756221-->



