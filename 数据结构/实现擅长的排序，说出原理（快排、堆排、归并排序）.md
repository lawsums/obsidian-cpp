
## 快速排序（Quick Sort）代码实现  
快速排序是分治法的经典应用，核心思想是**选择基准元素**，通过分区操作将数组分为“小于基准”和“大于基准”两部分，再递归排序子数组。


#### 1. 核心步骤  
- **分区（Partition）**：选择一个基准元素（如数组末尾元素），调整数组使得基准左侧元素均小于基准，右侧均大于基准，返回基准最终位置。  
- **递归排序**：以基准位置为界，递归对左右子数组执行相同操作，直至子数组长度为1（天然有序）。  


#### 2. C++代码实现  
```cpp
#include <vector>
#include <cstdlib> // 用于rand()
#include <ctime>   // 用于srand()
using namespace std;

// 辅助函数：交换两个元素
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// 分区函数：返回基准元素最终位置
int Partition(vector<int>& nums, int left, int right) {
    // 优化：随机选择基准（避免已排序数组的最坏情况）
    srand(time(0));
    int pivot_idx = left + rand() % (right - left + 1);
    swap(nums[pivot_idx], nums[right]); // 将基准移至末尾
    
    int pivot = nums[right]; // 基准值
    int i = left - 1; // i指向“小于基准”区域的最后一个元素
    
    // 遍历除基准外的元素，调整分区
    for (int j = left; j < right; j++) {
        if (nums[j] <= pivot) { // 若当前元素小于等于基准，加入“小于基准”区域
            i++;
            swap(nums[i], nums[j]);
        }
    }
    
    // 将基准移至正确位置（i+1是基准的最终索引）
    swap(nums[i + 1], nums[right]);
    return i + 1;
}

// 递归函数：排序子数组[left, right]
void QuickSortHelper(vector<int>& nums, int left, int right) {
    if (left >= right) return; // 子数组长度为1或0，递归终止
    int pivot = Partition(nums, left, right); // 分区并获取基准位置
    QuickSortHelper(nums, left, pivot - 1);   // 排序左子数组
    QuickSortHelper(nums, pivot + 1, right);  // 排序右子数组
}

// 主函数：快速排序入口
void QuickSort(vector<int>& nums) {
    if (nums.empty() || nums.size() == 1) return; // 边界条件
    QuickSortHelper(nums, 0, nums.size() - 1);
}
```


#### 3. 关键特性  
- **时间复杂度**：平均O(n log n)，最坏O(n²)（可通过随机基准优化至接近O(n log n)）；  
- **空间复杂度**：O(log n)（递归栈空间，最坏O(n)）；  
- **稳定性**：不稳定（分区交换可能改变相等元素的相对位置）。  


## 堆排序（Heap Sort）代码实现  
堆排序基于二叉堆结构，通过构建大根堆（升序）和反复提取堆顶元素实现排序。


#### 1. 核心步骤  
- **堆化（Heapify）**：调整节点与其子节点，确保父节点值大于子节点（大根堆）。  
- **构建初始堆**：从最后一个非叶子节点开始，对所有节点执行堆化，形成大根堆。  
- **提取极值并重构**：交换堆顶（最大值）与末尾元素，缩小堆范围后重新堆化，重复至排序完成。  


#### 2. C++代码实现  
```cpp
#include <vector>
using namespace std;

// 辅助函数：交换两个元素
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// 堆化函数：确保以i为根的子树满足大根堆性质
void Heapify(vector<int>& nums, int heap_size, int i) {
    int largest = i; // 初始化最大值为根节点
    int left = 2 * i + 1;  // 左子节点索引
    int right = 2 * i + 2; // 右子节点索引
    
    // 若左子节点大于根节点，更新最大值
    if (left < heap_size && nums[left] > nums[largest]) {
        largest = left;
    }
    // 若右子节点大于当前最大值，更新最大值
    if (right < heap_size && nums[right] > nums[largest]) {
        largest = right;
    }
    
    // 若最大值不是根节点，交换并递归堆化子树
    if (largest != i) {
        swap(nums[i], nums[largest]);
        Heapify(nums, heap_size, largest);
    }
}

// 主函数：堆排序入口
void HeapSort(vector<int>& nums) {
    int n = nums.size();
    if (n <= 1) return; // 边界条件
    
    // 步骤1：构建初始大根堆（从最后一个非叶子节点开始堆化）
    for (int i = n / 2 - 1; i >= 0; i--) {
        Heapify(nums, n, i);
    }
    
    // 步骤2：提取堆顶元素并重构堆
    for (int i = n - 1; i > 0; i--) {
        swap(nums[0], nums[i]); // 堆顶（最大值）与当前末尾元素交换
        Heapify(nums, i, 0);    // 缩小堆范围（大小为i），重新堆化根节点
    }
}
```


#### 3. 关键特性  
- **时间复杂度**：O(n log n)（构建堆O(n)，每次堆化O(log n)，共n次堆化）；  
- **空间复杂度**：O(1)（原地排序，仅需常数级额外空间）；  
- **稳定性**：不稳定（堆化交换可能改变相等元素的相对位置）。

## 归并排序（Merge Sort）简要解析与代码框架补充
归并排序是典型的**分治法（Divide and Conquer）** 排序算法，核心思想是“先分后合”——将数组拆分为子数组递归排序，再将有序子数组合并为整体有序数组。

#### 1. 核心原理
- **分（Divide）**：将待排序数组从中间拆分为左右两个子数组，递归拆分直至每个子数组仅含1个元素（单个元素默认有序）。  
- **合（Merge）**：创建临时数组，比较两个有序子数组的元素，按从小到大顺序将元素依次存入临时数组，最后将临时数组的有序元素拷贝回原数组，完成合并。

#### 2. C++代码框架补充（基于你提供的函数签名）
```cpp
#include <vector>
using namespace std;

// 辅助函数：合并两个有序子数组（左：[left, mid]，右：[mid+1, right]）
void Merge(vector<int>& nums, int left, int mid, int right) {
    vector<int> temp(right - left + 1); // 临时数组存储合并结果
    int i = left, j = mid + 1, k = 0;   // i：左子数组指针，j：右子数组指针，k：临时数组指针
    
    // 比较左右子数组元素，按序存入临时数组
    while (i <= mid && j <= right) {
        if (nums[i] <= nums[j]) {
            temp[k++] = nums[i++];
        } else {
            temp[k++] = nums[j++];
        }
    }
    
    // 处理左子数组剩余元素
    while (i <= mid) {
        temp[k++] = nums[i++];
    }
    // 处理右子数组剩余元素
    while (j <= right) {
        temp[k++] = nums[j++];
    }
    
    // 临时数组结果拷贝回原数组
    for (k = 0; k < temp.size(); k++) {
        nums[left + k] = temp[k];
    }
}

// 递归函数：拆分并排序子数组
void MergeSortHelper(vector<int>& nums, int left, int right) {
    if (left >= right) return; // 子数组仅1个元素，递归终止
    int mid = left + (right - left) / 2; // 避免溢出（替代 (left+right)/2）
    MergeSortHelper(nums, left, mid);    // 排序左子数组
    MergeSortHelper(nums, mid + 1, right); // 排序右子数组
    Merge(nums, left, mid, right);       // 合并两个有序子数组
}

// 主函数：归并排序入口
void MergeSort(vector<int>& nums) {
    if (nums.empty() || nums.size() == 1) return; // 边界条件：空数组或仅1个元素
    MergeSortHelper(nums, 0, nums.size() - 1);    // 调用辅助递归函数
}
```

#### 3. 关键特性
- **时间复杂度**：O(n log n)（拆分过程O(log n)层，每层合并O(n)）；  
- **空间复杂度**：O(n)（合并需临时数组，递归栈空间O(log n)可忽略，整体由临时数组主导）；  
- **稳定性**：稳定（合并时若元素相等，优先取左子数组元素，不改变相对位置）。