
## 怎么判断一个数是二的倍数

通过 `n & 1 == 0` 进行判断

``` python
for i in range(10):
	print(f"{i} {'is' if i & 1 == 0 else 'is not'} even")
```

## 怎么判断一个数是二次幂 ?

通过 `(n > 0) && (n & (n - 1) == 0)` 进行判断

```python
for i in range(10):
	print(f"{i} {'is' if (i > 0) and (i & (i - 1)) == 0 else 'is not'} the power of 2")
```

## 怎么求一个数中有几个 1

1. 遍历统计
2. 每次去除最左边的 1，直到数字变为零
3. 并行计算
4. \_\_builtin_popcount ()


### 1. 遍历统计（基础暴力法）
- **核心逻辑**：逐位检查数字的每一个二进制位，若该位为1则计数+1。  
- **操作步骤**：  
  1. 用“与运算（&）”判断当前最低位是否为1（如 `num & 1`，结果为1则最低位是1，为0则不是）；  
  2. 对数字进行“右移1位（>>1）”，相当于丢弃当前最低位，检查下一位；  
  3. 重复步骤1-2，直到数字变为0，最终计数即为1的总个数。  
- **特点**：逻辑简单易理解，但效率依赖数字的二进制位数（如32位整数需循环32次），适合位数较少或场景简单的情况。



### 2. 每次去除最左边的1（优化位运算法）
- **核心逻辑**：利用“`num & (num - 1)`”的特性——该运算会**清除数字二进制中最右边的1**（如 `num=6` 二进制为 `110`，`num-1=5` 为 `101`，`&` 结果为 `100`，即清除了最右边的1），每执行一次就对应一个1，计数+1，直到数字变为0。  
- **操作步骤**：  
  1. 初始化计数为0；  
  2. 若 `num != 0`，则执行 `num = num & (num - 1)`，同时计数+1；  
  3. 重复步骤2，直到 `num=0`，计数即为1的个数。  
- **特点**：效率更高，循环次数=1的实际个数（如含3个1仅需循环3次），比遍历法减少无效操作。


### 3. 并行计算（高效位运算，适合多位数）
- **核心逻辑**：通过“分治思想”，将二进制位按组（如2位、4位、8位等）并行统计每组内1的个数，再逐步合并结果，避免逐位遍历。  
- **示例（以8位二进制数为例）**：  
  1. 2位分组统计：`num = (num & 0x55) + ((num >> 1) & 0x55)`（`0x55` 是 `01010101`，统计每2位中1的个数，结果存到这2位中）；  
  2. 4位分组合并：`num = (num & 0x33) + ((num >> 2) & 0x33)`（`0x33` 是 `00110011`，合并相邻2组的结果）；  
  3. 8位分组合并：`num = (num & 0x0F) + ((num >> 4) & 0x0F)`（`0x0F` 是 `00001111`，最终得到8位中1的总个数）。  
- **特点**：无需循环，仅需固定几步位运算（如32位整数需5步），效率极高，适合对性能要求严格的场景（如底层开发）。
``` python
def count_bits(num: int) -> int:
	num = (num & 0x5555) + ((num >> 1) & 0x5555)
	num = (num & 0x3333) + ((num >> 2) & 0x3333)
	num = (num & 0x0F0F) + ((num >> 4) & 0x0F0F)
	num = (num & 0x00FF) + ((num >> 8) & 0x00FF)
	return num
	
for i in range(30): 
	print(f"count_bits({i}) = {count_bits(i)}")
```
 


### 4. `__builtin_popcount()`（编译器内置函数）
- **核心逻辑**：编译器（如GCC、Clang）提供的**内置函数**，直接调用底层优化的指令（如x86的`popcnt`指令、ARM的`vcnt`指令）统计二进制中1的个数，本质是“硬件加速的统计”。  
- **使用场景**：需包含标准头文件（如`<cstdint>`），参数通常为无符号整数（如`uint32_t`），返回值即1的个数（如 `__builtin_popcount(6)` 返回2，因6的二进制`110`含2个1）。  
- **特点**：代码简洁（一行调用）、速度最快（直接用硬件指令），但依赖编译器支持，可移植性略低于纯位运算（需确认编译器是否兼容）。
---
### 四种方法的时间复杂度对比
下表从“最坏情况”“平均情况”“时间复杂度本质”三个维度，结合输入规模（n=二进制位数，k=1的个数）进行详细对比：

| 方法                 | 最坏时间复杂度 | 平均时间复杂度 | 核心逻辑与复杂度本质                                                                 |
| -------------------- | -------------- | -------------- | ------------------------------------------------------------------------------------ |
| 1. 遍历统计（暴力法） | O(n)           | O(n)           | 需**逐位检查所有二进制位**（无论该位是否为1），循环次数固定为n（如32位整数必循环32次），与k无关。 |
| 2. 去除最右1（优化位运算） | O(k)           | O(k)           | 每轮循环仅清除1个“最右的1”，循环次数**等于1的实际个数k**（有k个1就循环k次），与n无关。若k极小（如数字为1，k=1），效率极高；若k=n（如全1的数字），退化为O(n)。 |
| 3. 并行计算（分治位运算） | O(1)           | O(1)           | 采用“分治思想”，通过**固定步数的位运算**完成统计（与n无关）：<br>- 32位整数需5步（2→4→8→16→32位合并）；<br>- 64位整数需6步；<br>无论n是多少，步数恒定，属于“常数时间”。 |
| 4. `__builtin_popcount()` | O(1) | O(1) | 调用编译器内置的**硬件指令**（如x86的`popcnt`、ARM的`vcnt`），指令执行仅需**1个CPU时钟周期**（与n、k均无关），本质是“硬件层面的常数时间”。 |


### 关键结论与复杂度优先级
从“效率高低”排序，四种方法的时间复杂度优先级为：  
**`__builtin_popcount()`（O(1)） ≈ 并行计算（O(1)） > 去除最右1（O(k)） > 遍历统计（O(n)）**  

具体分析如下：
1. **O(1) 方法（并行计算 & 内置函数）：效率天花板**  
   两者均无需循环，执行时间不随n或k增长——并行计算靠“固定步数位运算”，内置函数靠“硬件单指令”，在任何场景下都是最快的。  
   - 细微差异：内置函数（`__builtin_popcount()`）通常比并行计算更快，因硬件指令直接完成统计，无需多步位运算合并；但并行计算的优势是“纯软件实现，不依赖编译器/硬件支持”。

2. **O(k) 方法（去除最右1）：动态优化，依赖1的个数**  
   效率介于“O(1)”和“O(n)”之间：  
   - 当k极小时（如数字为`2^30`，二进制仅1个1），循环1次即可，效率接近O(1)；  
   - 当k极大时（如数字为`2^32-1`，32位全1），循环32次，退化为O(n)，与遍历统计效率相当。

3. **O(n) 方法（遍历统计）：效率最低，仅适合简单场景**  
   无论k是多少，都需遍历所有n个二进制位（如32位整数必循环32次），在n较大（如64位、128位数字）或对性能敏感的场景下，效率明显低于其他三种方法。


### 补充：为何不关注“数字的十进制大小”？
需注意：时间复杂度的“输入规模”并非“数字的十进制值（如数字是100还是10000）”，而是**二进制位数n**——因为数字的十进制值增长时，二进制位数n仅以“log₂(值)”的速度增长（如100的二进制是7位，10000的二进制是14位，n增长缓慢），但算法的执行次数直接由n决定，而非十进制值。因此，以n作为输入规模更贴合算法的实际执行逻辑。