---
excalidraw-plugin: parsed
tags:
  - excalidraw
excalidraw-open-md: true
---

DECK: 面试题-hot100

## 链式前向星


## 思路

链式前向星是图的一种**静态数组**实现
1. 比如说使用邻接矩阵的时候，空间的增长是平方级别的，
2. 使用邻接表的时候，空间的增长看似是线性的，但是由于使用的是动态 vector\<vector\<int\>\>, 在动态扩充空间的时候有很大的时间开销，而且为了对齐我认为空间上也不是线性增长的
3. 而链式前向星通过使用 next, to, head 等数组真正实现了空间的线性增长，所以我们就可以通过题目的要求去**精确预留空间**

对于一般的情况来说用不到，但是在竞赛场景很有用

---

你的理解核心是**准确**的！链式前向星的核心优势就是在竞赛等对时空复杂度敏感的场景中，平衡了“空间高效”和“访问高效”，下面用更简洁的逻辑补充解析，帮你理清关键细节：

### 1. 先回应你提到的三个核心对比（精准提炼）
- **邻接矩阵**：空间复杂度 O (n²)（n 是节点数），节点多（比如 n=1 e 4）时直接爆内存，适合稠密图，但竞赛中极少用（大多是稀疏图）；
- **邻接表（vector 实现）**：空间“理论线性”（O (n+m)，m 是边数），但动态扩容（vector 倍增扩容）会有**隐性时间开销**（拷贝元素），且扩容时会预留多余空间（比如当前容量满了就扩到 2 倍），实际空间略大于 O (n+m)，还可能有内存碎片；
- **链式前向星**：用三个数组（`head[]`：存每个节点的第一条边索引；`to[]`：存边的终点；`next[]`：存下一条边的索引），**严格线性空间 O (m)**（m 是边数，提前按题目给的最大边数开数组），无扩容开销，访问时通过“head 找起点 + next 遍历邻边”，效率和邻接表一致。

### 2. 关键补充：为什么竞赛偏爱它？
- 你说的“精确预留空间”是核心：竞赛题会明确给出“最多 m 条边”，直接开 `to[m+1]`、`next[m+1]`（数组下标从 1 开始更方便），完全没有浪费，也不会动态分配内存（C++ 中动态内存分配在竞赛中容易 TLE 或 MLE）；
- 实现简单：无需写链表结构，纯数组操作，代码短且不易出错，适合快速编码；
- 支持重边/反向边：竞赛中常需要处理重边（多条边连同一对节点）或反向边（建图时存反向边用于最短路、拓扑排序等），链式前向星只需继续往数组里填边，无需额外处理，比 vector 更灵活。

### 3. 适用场景总结
- 不用的情况：日常开发（数据量小，vector 方便且可读性高，无需纠结这点时空）；
- 必用的情况：竞赛中的**稀疏图**（m 远小于 n²，比如 n=1 e 5、m=2 e 5），需要极致的时空效率，避免动态扩容和内存浪费。

简单说，链式前向星就是“竞赛专用的静态邻接表”，把动态结构的灵活性和数组的高效性结合起来了，你的理解完全命中了它的设计初衷～

## 标准写法


```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 10;
const int MAXM = 21;

// 邻接矩阵形式
int graph1[MAXN][MAXN];

// 邻接表形式
vector<vector<pair<int, int>>> graph2;

// 链式前向星
int head[MAXN];
int next_[MAXM];
int to[MAXM];
int weight[MAXM];
int cnt; // 用来记录边号

void build(int n) {
    // 邻接矩阵清空
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            graph1[i][j] = 0;
        }
    }

    // 邻接表清空
    graph2.assign(n + 1, {});

    // 链式前向星清空
    cnt = 1;
    for (int i = 0; i < MAXN; i++) {
        head[i] = 0;
    }
}

// 链式前向星加边
void addEdge(int u, int v, int w) {
    next_[cnt] = head[u];
    to[cnt] = v;
    weight[cnt] = w;
    head[u] = cnt++; // head[u]需要更新
}

void directGraph(const vector<vector<int>>& edges) {
    for (const auto& edge : edges) {
        int u = edge[0], v = edge[1], w = edge[2];
        // 邻接矩阵
        graph1[u][v] = w;
        // 邻接表
        graph2[u].emplace_back(v, w);
        // 链式前向星
        addEdge(u, v, w);
    }
}

void undirectGraph(const vector<vector<int>>& edges) {
    for (const auto& edge : edges) {
        int u = edge[0], v = edge[1], w = edge[2];
        // 邻接矩阵
        graph1[u][v] = w;
        graph1[v][u] = w;
        // 邻接表
        graph2[u].emplace_back(v, w);
        graph2[v].emplace_back(u, w);
        // 链式前向星
        addEdge(u, v, w);
        addEdge(v, u, w);
    }
}

void traversal(int n) {
    // 邻接矩阵
    cout << "邻接矩阵遍历(权重)：" << endl;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << graph1[i][j] << ", ";
        }
        cout << endl;
    }

    // 邻接表
    cout << "邻接表遍历(邻居、边权)：" << endl;
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        for (const auto& edge : graph2[i]) {
            cout << "(" << edge.first << ", " << edge.second << "), ";
        }
        cout << endl;
    }

    // 链式前向星
    cout << "链式前向星遍历：" << endl;
    for (int i = 1; i <= n; i++) {
        cout << i << ": ";
        for (int ei = head[i]; ei > 0; ei = next_[ei]) {
            cout << "(" << to[ei] << ", " << weight[ei] << "), "; 
        }
        cout << endl;
    }
}


int main() {
    // 理解了带权图的建立过程，也就理解了不带权图
    // 点的编号为1...n
    // 例子1自己画一下图，有向带权图，然后打印结果
    int n1 = 4;
    vector<vector<int>> edges1 = {{1, 3, 6}, {4, 3, 4}, {2, 4, 2}, {1, 2, 7}, {2, 3, 5}, {3, 1, 1}};
    build(n1);
    directGraph(edges1);
    traversal(n1);
    cout << "==============================" << endl;
    
    // 例子2自己画一下图，无向带权图，然后打印结果
    int n2 = 5;
    vector<vector<int>> edges2 = {{3, 5, 4}, {4, 1, 1}, {3, 4, 2}, {5, 2, 4}, {2, 3, 7}, {1, 5, 5}, {4, 2, 6}};
    build(n2);
    undirectGraph(edges2);
    traversal(n2);
    
    cin.get();
    return 0;
}
```




END
<!--ID: 1763802691299-->
