
## 模版



## 容器

1. vector
2. list
3. deque
4. map
5. multimap
6. set
7. multiset

---

在编程领域，**模板（Template）** 和 **容器（Container）** 是两类核心概念，前者是“通用代码的蓝图”，后者是“数据的存储与管理结构”，二者常结合使用（如C++ STL的容器本质是模板实现的），以下从概念、实现逻辑、示例三方面解析：


### 一、核心概念区分
| 维度         | 模板（Template）                          | 容器（Container）                          |
|--------------|-------------------------------------------|-------------------------------------------|
| 核心作用     | 解决“代码复用”，让同一套逻辑适配不同数据类型 | 解决“数据存储”，管理一组数据的存储、访问、增删 |
| 本质         | 编译期的“代码生成工具”（无实际内存占用）   | 运行期的“数据结构实例”（占用内存存储数据）   |
| 典型场景     | 通用函数（如比较两个值）、通用类（如容器） | 存储列表（如数组）、集合（如去重数据）、映射（如键值对） |


### 二、模板的实现：以“通用比较函数”为例
模板的核心是**“类型参数化”**——将代码中不确定的数据类型定义为“参数”，编译时根据传入的实际类型生成对应代码（避免为int、float、string重复写相同逻辑）。

#### 1. 实现逻辑
- 用关键字声明“类型参数”（如C++的`template <typename T>`，Java的`<T>`）；
- 代码中用“类型参数”（如T）代替具体类型；
- 调用时传入实际类型（如`compare<int>(a,b)`），编译期生成对应类型的代码。

#### 2. 代码示例（C++）
```cpp
#include <iostream>
using namespace std;

// 1. 声明模板：T是“类型参数”，代表任意数据类型
template <typename T>
// 2. 通用比较函数：适配int、float、string等所有支持“<”的类型
T maxValue(T a, T b) {
    return (a > b) ? a : b;
}

int main() {
    // 3. 调用时指定类型，编译期生成对应版本的函数
    int a = 5, b = 3;
    cout << maxValue<int>(a, b) << endl;  // 生成int版，输出5
    
    float c = 2.1, d = 3.5;
    cout << maxValue<float>(c, d) << endl; // 生成float版，输出3.5
    
    string e = "apple", f = "banana";
    cout << maxValue<string>(e, f) << endl;// 生成string版，输出banana
    return 0;
}
```


### 三、容器的实现：以“动态数组容器”为例
容器的核心是**“封装数据结构”**——隐藏底层存储细节（如数组、链表），对外提供统一的操作接口（如添加`add`、删除`remove`、访问`get`），方便用户管理数据。

#### 1. 实现逻辑
- 底层选择合适的存储结构（如固定数组，用于动态扩容）；
- 封装“容量管理”（如初始容量、满了自动扩容）；
- 提供操作接口（增删查改），屏蔽底层细节。

#### 2. 代码示例（Java，结合泛型=模板思想）
```java
import java.util.Arrays;

// 自定义动态数组容器：用泛型<T>实现“适配任意类型”（模板思想）
public class MyList<T> {
    // 底层存储：Object数组（可存任意类型，转型为T）
    private Object[] data;
    // 当前元素个数
    private int size;
    // 初始容量
    private static final int INIT_CAP = 10;

    // 构造器：初始化容器
    public MyList() {
        data = new Object[INIT_CAP];
        size = 0;
    }

    // 1. 核心接口：添加元素（满了则扩容）
    public void add(T element) {
        // 扩容逻辑：当元素个数=数组长度，容量翻倍
        if (size == data.length) {
            data = Arrays.copyOf(data, data.length * 2);
        }
        data[size] = element; // 存元素
        size++; // 个数+1
    }

    // 2. 核心接口：获取指定索引的元素
    public T get(int index) {
        // 合法性校验
        if (index < 0 || index >= size) {
            throw new IndexOutOfBoundsException("索引越界");
        }
        return (T) data[index]; // 转型为T类型返回
    }

    // 3. 辅助接口：获取元素个数
    public int size() {
        return size;
    }

    // 测试：存储不同类型数据
    public static void main(String[] args) {
        // 存储int（自动装箱为Integer）
        MyList<Integer> intList = new MyList<>();
        intList.add(10);
        intList.add(20);
        System.out.println(intList.get(1)); // 输出20

        // 存储String
        MyList<String> strList = new MyList<>();
        strList.add("模板");
        strList.add("容器");
        System.out.println(strList.get(0)); // 输出“模板”
    }
}
```


### 四、模板与容器的结合：为什么容器需要模板？
如果没有模板（泛型），容器只能存储“单一类型”（如只能存int的数组），要存string就得重写一套容器代码——**模板让容器成为“通用数据结构”**，一套代码适配所有类型（如Java的`ArrayList<T>`、C++的`vector<T>`，本质都是“模板实现的容器”）。

比如C++的`vector`（动态数组容器）就是模板类：
```cpp
#include <vector>
using namespace std;

int main() {
    vector<int> intVec;    // 存int的容器
    vector<string> strVec; // 存string的容器
    intVec.push_back(10);  // 调用模板生成的int版push_back
    strVec.push_back("a"); // 调用模板生成的string版push_back
    return 0;
}
```