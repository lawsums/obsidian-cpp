

DECK: 面试题-hot100

## 环形链表


## 思路

这道题就哈希表解法来说并不难，但是快慢指针的做法并不容易理解，所以我借助了大模型
以下是**豆包**给出的证明，还是说的不错的
### 证明思路
这个算法的核心原理是：**如果链表有环，那么以不同速度前进的两个指针最终一定会在环内相遇；如果链表无环，快指针会率先走到链表末尾（指向 `nullptr`）**。下面我分两种情况严谨证明：

#### 1. 先证明「无环时算法返回 false」（正确性的必要条件）
- 当链表无环时，链表是一条单向的线性结构，最后一个节点的 `next` 指向 `nullptr`。
- 快指针 `fast` 每次走两步，慢指针 `slow` 每次走一步，`fast` 会比 `slow` 更快到达链表末尾。
- 循环条件是 `fast != nullptr && fast->next != nullptr`：
  - 如果 `fast` 先走到最后一个节点（`fast->next == nullptr`），循环终止；
  - 如果链表长度为偶数，`fast` 会直接走到 `nullptr`，循环也会终止。
- 循环终止后执行 `return false`，符合「无环返回 false」的逻辑，这部分是显然成立的。

#### 2. 重点证明「有环时快慢指针一定会相遇（返回 true）」
假设链表存在环，我们分两步分析：

##### 步骤1：定义变量与场景
- 设链表的「非环部分长度」为 `a`（即从头节点到环入口有 `a` 个节点）；
- 设环的长度为 `b`（环内有 `b` 个节点）；
- 慢指针 `slow` 每次走 1 步，快指针 `fast` 每次走 2 步；
- 当 `slow` 走到环入口时，它已经走了 `a` 步，此时 `fast` 已经走了 `2a` 步：
  - `fast` 在非环部分走了 `a` 步，剩下的 `a` 步是在环内走的，因此 `fast` 此时在环内的位置是：`a % b`（即距离环入口 `a % b` 步的位置）。

##### 步骤2：计算相遇条件
此时 `slow` 和 `fast` 都进入了环，两者的「相对距离」为：`b - (a % b)`（因为 `fast` 在环内领先 `a % b` 步，所以 `slow` 要追上 `fast` 需要走 `b - (a % b)` 步）。
- `slow` 每次走 1 步，`fast` 每次走 2 步 → 两者的「相对速度」是 1 步/次（`fast` 相对于 `slow` 每次靠近 1 步）。
- 因此，经过 `b - (a % b)` 次移动后，`fast` 会追上 `slow`（相对距离减到 0），此时 `slow == fast`，算法返回 `true`。

##### 补充说明
可能有人会问：会不会出现「快指针刚好跳过慢指针」的情况？
答案是不会：因为相对速度是 1 步/次，每次只靠近 1 步，而环是连续的节点，不存在「跳过」的可能——要么相遇，要么继续靠近，直到相遇。

### 总结
这段代码的正确性可以总结为两个核心点：
1. **无环场景**：快指针会率先到达链表末尾（`fast` 或 `fast->next` 为 `nullptr`），循环终止并返回 `false`，逻辑正确；
2. **有环场景**：慢指针进入环后，快指针与慢指针的相对速度为 1 步/次，有限步内必然追上（相遇），此时返回 `true`，必然成立。

简单来说，快慢指针的本质是利用「速度差」将「链表有环」的问题转化为「环内追及问题」，而追及问题中，只要速度差恒定且运动空间是闭环，就一定能相遇。

## 标准解法

```cpp
// 快慢指针实现
class Solution {
public:
    bool hasCycle(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
};
```


## 我的解法

```cpp
// 哈希表实现
class Solution {
public:
    bool hasCycle(ListNode *head) {
        unordered_map<ListNode*, int> mp;

        ListNode *cur;
        for (cur = head; cur != nullptr; cur = cur->next) {
            if (mp.count(cur)) return true;
            mp[cur]++;            
        }
        
        return false;
    }
};

```

END
<!--ID: 1765209754343-->

