

DECK: 面试题-hot100

## 最长递增子序列


## 思路



## 标准解法

```python
# 正确答案：动态规划法
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        stk = []
        ans = 0
        for num in nums:
            # 如果stk不为空，而且不能维持严格递增，就弹出元素
            while stk and num <= stk[-1]:
                stk.pop()
            stk.append(num)
            ans = max(ans, len(stk))
        return ans

```


## 我的解法

```python
# 错误答案：单调栈
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        stk = []
        ans = 0
        for num in nums:
            # 如果stk不为空，而且不能维持严格递增，就弹出元素
            while stk and num <= stk[-1]:
                stk.pop()
            stk.append(num)
            ans = max(ans, len(stk))
        return ans

```



## 这题为什么不能使用单调栈？

要回答这个问题，核心结论是：**这道题既不是“必须用动态规划”，也不是“不能用单调栈”——而是单调栈无法正确求解 LIS 长度，而动态规划（DP）/贪心+二分是可行的；且贪心+二分效率远高于纯 DP**。

我们先拆解「为什么单调栈不行」，再对比「DP 为什么可行」，最后理清三者的核心区别。

### 一、先明确：单调栈的核心问题——无法处理“非连续递增”的最长子序列
单调栈的核心作用是**维护“连续/局部”的单调性**（比如接雨水、柱状图最大矩形、下一个更大元素等问题），但 LIS 的核心是「非连续的全局最长递增子序列」，两者的适配性完全不匹配。

以你之前的例子 `[0,8,4,12,2,14,16]` 为例，尝试用单调栈模拟（假设想维护递增栈）：
| 步骤 | 元素 | 单调栈变化（递增） | 问题暴露 |
|------|------|--------------------|----------|
| 1    | 0    | [0]                | 正常     |
| 2    | 8    | [0,8]              | 正常     |
| 3    | 4    | 弹出 8 → [0,4]      | 栈长度从 2→2，但此时“长度为 2 的 LIS 最小末尾”优化为 4（看似对） |
| 4    | 12   | [0,4,12]           | 正常     |
| 5    | 2    | 弹出 12、4 → [0,2]  | 栈长度从 3→2（致命问题：丢失了“长度为 3 的 LIS（0,4,12）”的信息） |
| 6    | 14   | [0,2,14]           | 栈长度 3（但真实 LIS 此时已能到 4） |
| 7    | 16   | [0,2,14,16]        | 栈长度 4（但真实 LIS 长度是 5） |

#### 单调栈的致命缺陷：
1. **丢失历史有效信息**：单调栈在遇到更小元素时，会**弹出所有比它大的元素**（保证栈的单调性），但这些被弹出的元素可能是“更长子序列的末尾”（比如例子中弹出 12、4 后，就丢失了“长度为 3 的 LIS”的信息）；
2. **只能记录局部连续递增**：单调栈的长度反映的是「以当前元素结尾的最长连续递增子序列长度」，而非「全局非连续的 LIS 长度」；
3. 最终栈长度为 4，但真实 LIS 长度是 5——结果完全错误。

### 二、动态规划（DP）为什么可行？
DP 的核心是「记录全局状态，不丢失历史信息」，针对 LIS 的 DP 定义如下：
- 状态：`dp[i]` 表示「以 `nums[i]` 结尾的最长递增子序列长度」；
- 转移：遍历 `j < i`，若 `nums[j] < nums[i]`，则 `dp[i] = max(dp[i], dp[j]+1)`；
- 结果：`max(dp)` 即为 LIS 长度。

以 `[0,8,4,12,2,14,16]` 为例，DP 数组的计算过程：
  

| i   | nums[i] | dp [i]（以 nums [i] 结尾的 LIS 长度）   | 推导逻辑            |
| --- | ------- | ------------------------------- | --------------- |
| 0   | 0       | 1                               | 初始值             |
| 1   | 8       | 2（dp[0]+1）                      | 0<8             |
| 2   | 4       | 2（dp[0]+1）                      | 0<4，8>4         |
| 3   | 12      | 3（max (dp[0], dp[1], dp[2])+1=2+1） | 0/8/4 <12       |
| 4   | 2       | 2（dp[0]+1）                      | 0<2，8/4/12>2    |
| 5   | 14      | 4（dp[3]+1=3+1）                  | 0/8/4/12 <14    |
| 6   | 16      | 5（dp[5]+1=4+1）                  | 0/8/4/12/14 <16 |

最终 `max(dp)=5`，和真实 LIS 长度一致——**DP 通过遍历所有前驱元素，完整保留了“以每个元素结尾的最长子序列”信息，因此能正确计算全局最优解**。

### 三、贪心+二分：比 DP 更高效的最优解（不是 DP，但比 DP 更好）
你之前看到的 `d` 数组解法（贪心+二分），既不是单调栈也不是纯 DP，而是结合了贪心的“优化末尾”和二分的“快速查找”，时间复杂度 O (n log n)（DP 是 O (n²)）：
- 核心优势：不丢失“长度为 k 的 LIS 最小末尾”的信息（比如替换 2 后，依然保留“长度为 3 的 LIS 末尾是 12”的信息）；
- 结果：对于 `[0,8,4,12,2,14,16]`，最终 `d=[0,2,12,14,16]`，长度 5，和真实 LIS 长度一致。

### 四、三者核心区别总结
| 方法       | 核心逻辑                  | 能否正确求 LIS 长度 | 时间复杂度 | 适用场景                     |
|------------|---------------------------|------------------|------------|------------------------------|
| 单调栈     | 维护局部连续递增，弹出更大元素 | ❌ 不能          | O (n)       | 下一个更大元素、接雨水等“局部单调”问题 |
| 动态规划   | 记录以每个元素结尾的 LIS 长度 | ✅ 能            | O (n²)      | 小数据量的 LIS、需要还原具体子序列 |
| 贪心+二分  | 维护“长度为 k 的 LIS 最小末尾” | ✅ 能            | O (n log n) | 大数据量的 LIS（仅需长度）|

### 五、关键结论
1. **不是“必须用 DP”**：贪心+二分是更优的解法，只是 DP 是最容易理解的基础解法；
2. **单调栈不行的本质**：单调栈的“弹出”操作会丢失 LIS 所需的全局历史信息，只能处理“连续/局部单调”问题，无法处理“非连续全局最长递增子序列”；
3. 如果你尝试用单调栈解 LIS，会发现：
   - 对于严格递增序列（如[1,2,3,4]），结果正确（巧合）；
   - 对于存在“中间更小元素”的序列（如[0,8,4,12]），结果错误（必然）。

简单来说：LIS 的核心是“全局非连续的最长递增”，而单调栈的核心是“局部连续的单调性维护”——两者的问题目标完全不匹配，因此单调栈无法正确求解 LIS。


END
<!--ID: 1765512249955-->

