

DECK: 面试题-hot100

## 堆


## 思路


## 两个堆模板

### 1. 用于 push/pop 的堆类模板（大顶堆）

```cpp
class MaxHeap {
private:
    vector<int> h;
    
    void sift_up(int i) {
        while (i > 0 && h[i] > h[(i - 1) / 2]) {
            swap(h[i], h[(i - 1) / 2]);
            i = (i - 1) / 2;
        }
    }
    
    void sift_down(int i) {
        int n = h.size();
        while (2 * i + 1 < n) {
            int l = 2 * i + 1, r = l + 1;
            int max_child = l;
            if (r < n && h[r] > h[l]) max_child = r;
            
            if (h[i] < h[max_child]) {
                swap(h[i], h[max_child]);
                i = max_child;
            } else break;
        }
    }
    
public:
    void push(int x) {
        h.push_back(x);
        sift_up(h.size() - 1);
    }
    
    void pop() {
        if (empty()) return;
        swap(h[0], h.back());
        h.pop_back();
        if (!empty()) sift_down(0);
    }
    
    int top() { return h[0]; }
    bool empty() { return h.empty(); }
    int size() { return h.size(); }
};

// 用作最小堆的技巧：push(-x)，top()返回 -h.top()
```

**背诵口诀**：
- `push`：先尾插，再上浮
- `pop`：先交换，再尾删，最后下沉
- `sift_up`：比父大就交换，向上爬
- `sift_down`：找最大孩子，比孩子小就交换，向下沉

### 2. 用于自底向上堆化排序的模板（原地堆排序）

```cpp
void heap_sort(vector<int>& arr) {
    int n = arr.size();
    
    // 1. 建堆：从最后一个非叶节点开始堆化
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }
    
    // 2. 排序：依次将堆顶（最大值）交换到末尾
    for (int i = n - 1; i > 0; i--) {
        swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}

// 堆化函数（大顶堆）
void heapify(vector<int>& arr, int n, int i) {
    while (true) {
        int l = 2 * i + 1, r = l + 1;
        int max_idx = i;
        
        if (l < n && arr[l] > arr[max_idx]) max_idx = l;
        if (r < n && arr[r] > arr[max_idx]) max_idx = r;
        
        if (max_idx == i) break;
        
        swap(arr[i], arr[max_idx]);
        i = max_idx;
    }
}
```

**背诵口诀**：
- `heap_sort`：两步走：先建堆（从 n/2-1 倒序），再排序（从 n-1 倒序）
- `heapify`：三比较（左、右、当前），选最大，不相等就交换
- 原地排序：O (1) 空间，O (n log n) 时间

### 使用示例

```cpp
// 最大堆使用
MaxHeap max_h;
max_h.push(3); max_h.push(1); max_h.push(4);
cout << max_h.top(); // 4
max_h.pop();

// 最小堆（用最大堆模拟）
MaxHeap min_h;
min_h.push(-3); min_h.push(-1); min_h.push(-4);
cout << -min_h.top(); // 1（实际是最小值）

// 堆排序
vector<int> nums = {3, 1, 4, 1, 5, 9, 2, 6};
heap_sort(nums); // 原地排序
```

这两个模板非常精简，总共约 50 行代码，涵盖了堆的所有核心操作。第一个模板适合动态插入删除的场景（如优先队列），第二个模板适合静态数组排序。


END
<!--ID: 1765209754335-->

