
DECK: 面试题

## 请你说一说操作系统中的程序的内存结构


## 标准答案
![[Pasted image 20251120220741.png]]


### 一、存储时（未调入内存，即磁盘上的可执行文件）
仅包含3个核心段，核心是「只存“必要数据”，节省文件体积」：
1. **代码段（text段）**：  
   - 存程序执行代码（指令）+ 只读常量（如字符串常量）；  
   - 编译时确定大小，只读（防止意外修改代码）；  
   - 必须存入文件（程序运行的核心指令）。

2. **数据段（已初始化数据区）**：  
   - 存「已初始化的全局变量、静态变量」（含它们的值）；  
   - 编译时分配空间，必须存入文件（要保留初始化的值）；  
   - 属于静态分配（生命周期随程序，结束后系统释放）。

3. **BSS段（未初始化数据区）**：  
   - 存「未初始化的全局变量、静态变量」；  
   - 编译时仅记录“需要的内存大小”，**不占用文件空间**（因为内核运行前会自动把这块内存清0，无需存文件）；  
   - 也属于静态分配，运行时由链接器申请内存，紧跟在数据段后。

### 二、运行时（调入内存后）
在「存储时3段」基础上，新增2个动态内存区域，满足程序运行中的临时需求：
1. **栈区**：  
   - 用途：存函数参数、局部变量（非静态）、函数调用上下文（返回地址等）；  
   - 管理：编译器自动分配/释放（函数调用时压栈，函数返回时弹栈）；  
   - 特点：连续内存、从高地址向低地址增长、空间有限（超界则栈溢出）、效率极高（操作简单）。

2. **堆区**：  
   - 用途：动态分配内存（如C的`malloc`/C++的`new`）；  
   - 管理：程序员手动申请/释放（忘记释放会内存泄漏）；  
   - 特点：位于BSS段和栈区之间、从低地址向高地址增长、非连续（频繁分配/释放会产生碎片）、效率低于栈（需通过算法查找可用空间）。

### 核心总结
- 「存储时」：关注“文件体积”，只存代码（text）和已初始化数据（data），BSS段仅记录大小不占文件空间；  
- 「运行时」：关注“动态需求”，新增栈（自动管理）和堆（手动管理），补充静态段的不足；  
- 本质：程序的内存布局是“静态结构（编译链接确定）+ 动态结构（运行时动态生成）”的结合，兼顾空间效率和运行灵活性。
、
## 我的答案

1. 堆
2. 栈
3. 代码段
4. 数据段


END
<!--ID: 1763801938384-->
