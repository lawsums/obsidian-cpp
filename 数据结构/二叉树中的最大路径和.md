tOnSave": true

DECK: 面试题-hot100

## 二叉树中的最大路径和


## 思路

通过每个节点 
1. 假设自己是**拐点**尝试更新**全局最大值**
2. 返回值只返回**最大的不拐弯的**一条路径
这样**自底向上**构建答案

## 标准解法

### C++
```cpp
// 方法一
class Solution {
private:
    int max_ = INT_MIN;

public:
    int maxPathSum(TreeNode* root) {
        f(root);
        return max_;
    }

    int f(TreeNode* node) {
        if (!node) return 0;

        int left_gain = max(0, f(node->left));
        int right_gain = max(0, f(node->right));
        max_ = max(max_, 
                   left_gain + right_gain + node->val);
        
        return max(left_gain + node->val, 
                   right_gain + node->val);

    }

// 方法二 树形dp
struct Info {
    int gain;  // 从当前节点向下延伸的最大路径和（单分支）
    int sum;   // 以当前节点为根的子树的最大路径和（可跨分支）

    Info(int gain, int sum) : gain(gain), sum(sum) {}
};

class Solution {
private:
    Info f(TreeNode* node) {
        if (!node) return Info(0, INT_MIN); // 空节点gain为0，sum为极小值

        auto infoL = f(node->left);
        auto infoR = f(node->right);

        // 1. 计算gain：当前节点值 + 左/右分支中更大的那个（如果为负则取0，相当于不选）
        int gain = node->val + max({infoL.gain, infoR.gain, 0});

        // 2. 计算sum：需要比较4种情况
        // - 左子树的最大sum
        // - 右子树的最大sum
        // - 当前节点跨左右分支的和（node->val + infoL.gain + infoR.gain）
        // - 仅当前节点自己（已经包含在gain中）
        int crossSum = node->val + infoL.gain + infoR.gain;
        int sum = max({infoL.sum, infoR.sum, crossSum});

        return Info(gain, sum);
    }

public:
    int maxPathSum(TreeNode* root) {
        return f(root).sum;
    }
};

```


### Python
```python
class Solution:
    def maxPathSum(self, root: Optional[TreeNode]) -> int:
        self.max_sum = float('-inf')
        
        def max_gain(node):
            if not node:
                return 0
                
            # 递归计算左右子树的最大贡献值
            left_gain = max(max_gain(node.left), 0)
            right_gain = max(max_gain(node.right), 0)
            
            # 当前节点作为路径拐点的路径和
            price_newpath = node.val + left_gain + right_gain
            
            # 更新全局最大值
            self.max_sum = max(self.max_sum, price_newpath)
            
            # 返回当前节点的最大贡献值（只能选择一条路径）
            return node.val + max(left_gain, right_gain)
        
        max_gain(root)
        return self.max_sum
```

## 我的解法

错了


END
<!--ID: 1763475115767-->



