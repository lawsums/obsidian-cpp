
DECK: 面试题-hot100

## 接雨水

接雨水这个问题非常经典，主要可以用两种解法去写
1. 前后缀
2. 左右指针

## 思路

主要要思考短板效应
但是这道题又与之前[[盛最多水的容器]]这道题不一样，因为那道题是需要去思考**挑选不同的两个柱子的总覆盖面积**，而这道题中是求全局范围，而且需要考虑柱子本身高度

---

这个问题非常好！**接雨水**和**盛最多水的容器**确实是两个看似相似但解法完全不同的题目：

## 📊 问题本质区别

### **接雨水 (Trapping Rain Water)**
- **问题**：计算所有柱子能接住的总雨水量
- **特点**：每个位置的蓄水量取决于**左右两侧的最高柱子**
- **核心公式**：`water[i] = min(left_max[i], right_max[i]) - height[i]`
- **为什么能用前后缀**：因为需要知道每个位置**左右两侧的最大值**

### **盛最多水的容器 (Container With Most Water)**
- **问题**：找到两条柱子，使它们与 x 轴构成的容器容量最大
- **特点**：容量取决于**两条柱子的距离和较矮柱子的高度**
- **核心公式**：`area = (right - left) * min(height[left], height[right])`
- **为什么不能用前后缀**：因为需要**同时考虑宽度和高度**的动态组合

## 🎯 解法差异深度分析

### **接雨水 - 前后缀分解适用原因**
```cpp
// 前后缀最大值数组
left_max[i] = max(height[0...i])
right_max[i] = max(height[i...n-1])
// 每个位置独立计算
water += min(left_max[i], right_max[i]) - height[i]
```
**关键**：每个位置的解只依赖于左右极值，不依赖于其他位置的选择

### **盛最多水的容器 - 双指针适用原因**
```cpp
int left = 0, right = n-1, max_area = 0;
while (left < right) {
    max_area = max(max_area, (right-left) * min(height[left], height[right]));
    if (height[left] < height[right]) left++;
    else right--;
}
```
**关键**：需要动态调整边界，因为容量受**距离和高度双重影响**

## 🔍 为什么盛水容器不能用前后缀？

假设用前后缀方法：
```cpp
// 这样是错的！
for (int i = 0; i < n; i++) {
    // 无法确定另一边界在哪里
    // 容量 = 距离 × 高度，但距离是变化的
}
```

**根本原因**：盛水容器的解是**全局最优**，需要同时考虑两个边界的位置关系；而接雨水是**局部计算**，每个位置独立。

## 📝 总结对比

| 特性 | 接雨水 | 盛最多水的容器 |
|------|--------|----------------|
| **问题类型** | 局部累加 | 全局最优 |
| **依赖关系** | 每个位置独立 | 两个位置相互依赖 |
| **关键因素** | 左右最大值 | 距离 × 高度 |
| **适用算法** | 前后缀数组 | 双指针 |
| **时间复杂度** | O (n) | O (n) |
| **空间复杂度** | O (n) | O (1) |

**简单记忆**：
- 接雨水：**看左右最高**，用前后缀
- 盛水容器：**看宽度和高度**，用双指针

理解这个区别对掌握这两种经典问题很有帮助！

## 标准解法

![[接雨水.cpp]]
```dataviewjs
// 嵌入单个 C++ 文件
const filePath = "数据结构/接雨水.cpp";
const file = this.app.vault.getAbstractFileByPath(filePath);

if (file) {
    const content = await this.app.vault.read(file);
    dv.el("pre", "```cpp\n" + content + "\n```");
} else {
    dv.el("p", "文件未找到: " + filePath);
}
```

## 我的解法



END
<!--ID: 1763829184934-->
