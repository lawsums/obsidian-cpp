
```` tab
tab: 归并排序
``` cpp
void Merge(int start, int mid, int end, vector<int>& nums) {
    if (start >= end) return;

    vector<int> tmp;
    int p1 = start, p2 = mid + 1;
    while (p1 <= mid && p2 <= end) {
        if (nums[p1] <= nums[p2]) {
            tmp.push_back(nums[p1++]);
        } else {
            tmp.push_back(nums[p2++]);
        }
    }
    while (p1 <= mid) tmp.push_back(nums[p1++]);
    while (p2 <= end) tmp.push_back(nums[p2++]);

    for (int i = 0; i < tmp.size(); i++) {
        nums[start + i] = tmp[i];
    }
}

void MergeSort(int start, int end, vector<int>& nums) {
    if (start >= end) return;
    int mid = (start + end) / 2;
    
    MergeSort(start, mid, nums);
    MergeSort(mid + 1, end, nums);
    Merge(start, mid, end, nums);
}

void MergeSort(vector<int>& nums) {
    MergeSort(0, nums.size() - 1, nums);
}
```

tab: 快速排序
``` cpp
int Partition(int lo, int hi, vector<int>& nums) {

    int pivot = nums[lo];
    int i = lo + 1, j = hi; // 将这个位置暂时留给pivot
    while (i <= j) {
        while (i < hi && nums[i] <= pivot) i++;
        while (j > lo && nums[j] >= pivot) j--;
        if (i >= j) break;
        swap(nums[i], nums[j]);
    }

    swap(nums[lo], nums[j]); // 将pivot放到它应该待的位置
    return j;
}


void QuickSort(int lo, int hi, vector<int>& nums) {
    if (lo >= hi) return;

    int j = Partition(lo, hi, nums);
    QuickSort(lo, j - 1, nums);
    QuickSort(j + 1, hi, nums);
}

void QuickSort(vector<int>& nums) {
    QuickSort(0, nums.size() - 1, nums);
}

```

tab: 堆排序
``` cpp

``` 

   
````
